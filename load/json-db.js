load("synchronet-json.js");
/*     
	JSON database  - for Synchronet 3.15a+ (2011)

	-	code by mcmlxxix
	-	model concept by deuce
	-	dongs by echicken
	-	positive reinforcement by cyan
	-	function names by weatherman
	-	mild concern by digitalman 

	methods:
	
	-	Repository.query(client,query);
	-	Repository.cycle(Date.now());
	-	Repository.load();
	-	Repository.save(Date.now());
	-	Repository.lock(client,record,child_name,lock_type);
	-	Repository.read(client,record,child_name);
	-	Repository.write(client,record,child_name,data);
	-	Repository.create(client,record,child_name,data);
	-	Repository.delete(client,record,child_name);
	-	Repository.subscribe(client,record,child_name);
	-	Repository.unsubscribe(client,record,child_name);
	
	optional arguments:
	
	-	argv[0] = filename;
	
*/

if(!this.Repository) {

Repository = new (function() {
    
	var settings={

		/* record lock constants, incremental (do not change the order or value)  */
		LOCK_UNLOCK:-1,
		LOCK_NONE:undefined,
		LOCK_READ:1,
		LOCK_WRITE:2,
		
		/* file read buffer */
		FILE_BUFFER:65535,
		
		/* autosave interval */
		AUTO_SAVE:30 /*seconds*/ *1000,
		LAST_SAVE:-1,
		
		/* error constants */
		ERROR_INVALID_REQUEST:0,
		ERROR_OBJECT_NOT_FOUND:1,
		ERROR_NOT_LOCKED:2,
		ERROR_LOCKED_WRITE:3,
		ERROR_LOCKED_READ:4,
		ERROR_DUPLICATE_LOCK:5
	};
	
	/**************************** repository objects *****************************/
	/* locking object generated by Repository.lock() method 
	contains the type of lock requested, and the time at which the request came in
	TODO: possibly "expire" unfulfilled lock requests after a certain period */
	function Lock(lock_type,timestamp) {
		this.type=lock_type;
		this.timestamp=timestamp;
	}

	/* error object containing a description of the error */
	function Error(error_num,error_desc) {
		this.operation="ERROR";
		this.error_num=error_num;
		switch(error_num) {
		case settings.ERROR_INVALID_REQUEST:
			this.error_desc="Invalid record request";
			break;
		case settings.ERROR_OBJECT_NOT_FOUND:
			this.error_desc="Record not found";
			break;
		case settings.ERROR_NOT_LOCKED:
			this.error_desc="Record not locked";
			break;
		case settings.ERROR_LOCKED_WRITE:
			this.error_desc="Record locked for writing";
			break;
		case settings.ERROR_LOCKED_READ:
			this.error_desc="Record locked for reading";
			break;
		case settings.ERROR_DUPLICATE_LOCK:
			this.error_desc="Duplicate record lock request";
			break;
		default:
			this.error_desc="Unknown error";
			break;
		}
	}
	
	/* shadow properties generated by composite_sketch() 
	contains a relative object's subscribers, locks, and child name */
	function Shadow() {
		this._lock=[];
		this._lock_pending=false;
		this._subscribers=[];
	}

	/* record object returned by identify_remains() 
	contains the requested object, its shadow object,
	the prevailing lock state of that object (affected by parents/children),
	and a list of subscribers associated with that object or its parents */
	function Record(data,shadow,info) {
		this.data=data;
		this.shadow=shadow;
		this.info=info;
	}

	/* request object generated by Repository.queue() method
	contains the requested object parent, the specific child property requested,
	data (in the case of a PUT operation ) */
	function Request(client,operation,parent_name,child_name,data) {
		this.client=client;
		this.operation=operation;
		this.parent_name=parent_name;
		this.child_name=child_name;
		this.data=data;
	}

    /* in the event of a corrupt JSON object or database problem,
	it would be beneficial to be able to  single-out the affected
	module for correction, rather than destroy the entire database

	it would also allow for a much simpler mechanism for removing
	games you no longer wish to host (simply delete the db file and edit your service inis) */

	/*************************** repository data ******************************/
    /* database storage file */
	if(file_exists(argv[0])) {
		this.file=new File(argv[0]);
	}
	else {
		this.file=new File(system.data_dir + "db.json");
	}
    
    /* master database object */
    this.data={};
    
    /* database record subscription and locking object */
    this.shadow={};
	
	/* queued array of data requests (get/put/create/delete) */
	this.queue=[];
    
	/*************************** repository methods ****************************/
    /* subscribe a client to an object */
    this.subscribe = function(client,record,child_name) {
        record.shadow[child_name]._subscribers[client.id]=client;
        /*  TODO: track duplicate subscribers (deny?) and 
		expire existing subscribers after  certain amount of time, maybe */
    };
    
    /* unsubscribe a client from an object */
    this.unsubscribe = function(client,record,child_name) {
        delete record.shadow[child_name]._subscribers[client.id];
        /*  TODO: validate existing subscription 
		before attempting to delete */
    };
    
    /* The point of a read lock is *only* to prevent someone from
	getting a write lock... just a simple counter is usually enough. */
    this.lock = function(client,record,child_name,lock_type) {
	
		switch(lock_type) {
		/* if the client wants to read... */
		case settings.LOCK_READ:
			switch(record.info.lock_type) {
			case settings.LOCK_READ:
				/* if there are any pending write locks, deny */
				if(record.info.lock_pending) {
					return false;
				}
				/* otherwise, we can read lock */
				else {
					record.shadow[child_name]._lock[client.id] = new Lock(
						lock_type,
						Date.now()
					);
					return true;
				}
			/* we cant lock a record that is already locked for reading */
			case settings.LOCK_WRITE:
				return false;
			/* if the record isnt locked at all, we can lock */
			case settings.LOCK_NONE:
				record.shadow[child_name]._lock[client.id] = new Lock(
					lock_type,
					Date.now()
				);
				return true;
			}
			break;
		/* if the client wants to write... */
		case settings.LOCK_WRITE:
			switch(record.info.lock_type) {
			/* ...and the record is already locked, flag for pending write lock */
			case settings.LOCK_READ:
			case settings.LOCK_WRITE:
				record.shadow[child_name]._lock_pending=true;
				return false;
			/* ...and the record isnt locked, lock for writing and remove flag */
			case settings.LOCK_NONE:
				record.shadow[child_name]._lock[client.id] = new Lock(
					lock_type,
					Date.now()
				);
				record.shadow[child_name]._lock_pending=false;
				return true;
			}
			break;
		/* if the client wants to unlock, check credentials */
		case settings.LOCK_UNLOCK:
			/* if the client has a lock on this record, release the lock */
			if(record.shadow[child_name]._lock[client.id]) {
				delete record.shadow[child_name]._lock[client.id];
				return true;
			}
			/* otherwise deny */
			else {
				return false;
			}
		}
		/* fallthrough? */
		return false;
    };
    
    /* server's data retrieval method (not directly called by client) */    
    this.read = function(client,record,child_name) {
		/* if this client has this record locked, read */
		if(record.shadow[child_name]._lock[client.id]) {
            client.send(record.data[child_name]);
			return true;
		}
        /* if there is no lock for this client, error */
        else {
            client.send(new Error(settings.ERROR_NOT_LOCKED));
            return false;
        }
    };
    
    /* server's data submission method (not directly called by client) */    
    this.write = function(client,record,child_name,data) {
	
		/* if this client has this record locked  */
		if(record.shadow[child_name]._lock[client.id] && 
		record.shadow[child_name]._lock[client.id].type == settings.LOCK_WRITE) {
			record.data=data;
			record.shadow=composite_sketch(data);
			/* send data updates to all subscribers */
			send_updates(record);
			return true;
		}
        /* if there is no lock for this client, error */
        else {
            client.send(new Error(settings.ERROR_NOT_LOCKED));
            return false;
        }
    };
    
    /* remove a record from the database (requires WRITE_LOCK) */
    this.delete = function(client,record,child_name) {
		/* if this client has this record locked */
		if(record.shadow[child_name]._lock[client.id] && 
		record.shadow[child_name]._lock[client.id].type == settings.LOCK_WRITE) {
			delete record.data[child_name];
			delete record.shadow[child_name];
			/* send data updates to all subscribers */
			send_updates(record);
			return true;
		}
        /* if there is no lock for this client, error */
        else {
            client.send(new Error(settings.ERROR_NOT_LOCKED));
            return false;
        }
    };

    /*  create a new database record (requires WRITE_LOCK) 
	TODO: it seems this method may end up doing the exact same thing 
	as the put() method, do we need it? can we lock an object that
	doesn't yet exist? does it matter? */
    this.create = function(client,record,child_name,data) {

        /* let parent adopt this new child */
        record.data[child_name] = data;
        /* create shadow data for this object */
        record.shadow[child_name] = composite_sketch(data);
		/* send data updates to all subscribers */
		send_updates(record);

        /* TODO: track subscribers and distribute updates */
        return true;
    };
	
	/* generic query handler, will process locks, reads, writes, and unlocks
	and put them into the appropriate queues */
	this.query = function(client,query) {
	
        /* strip the last child identifier from the string */
        var parent_name = query.object_name.substring(0,query.object_name.lastIndexOf("."));
        /* store the child name */
        var child_name = query.object_name.substr(query.object_name.lastIndexOf(".")+1);
		/* temporary array for queue additions */
		var q=[];
		/* push this query into a queue to be processed at the next response cycle (this.cycle()) */;
		q.push(new Request(
			client,
			query.operation,
			parent_name,
			child_name,
			query.data
		));
		/* if there is an attached lock operation, process accordingly */
		switch(query.lock) {
		/* if this is a read or write lock, put it ahead of the operation in the request queue */
		case settings.LOCK_READ:
		case settings.LOCK_WRITE:
			q.unshift(new Request(
				client,
				"LOCK",
				parent_name,
				child_name,
				query.lock
			));
			break;
		/* if this is an unlock, process it after the operation in the request queue */
		case settings.LOCK_UNLOCK:
			q.push(new Request(
				client,
				"LOCK",
				parent_name,
				child_name,
				query.lock
			));
			break;
		/* if no lock has been specified, do nothing */
		case settings.LOCK_NONE:
			break;
		}
		/* add the temporary queue to the main queue */
		this.queue=this.queue.concat(q);
	}
    
    /* internal periodic data storage method 
	TODO: this should probably eventually be a background
	thread to prevent lag when writing a large database to file */
    this.save = function(timestamp) { 
        /* strip _location tags from data before saving */
        dismember(this.data);
        //TODO: create n backups before overwriting data file
        this.file.open("w");
        // This function gets called every 30 seconds or so
        // And flushes all objects to disk in case of crash
        // Also, this is called on clean exit.
        this.file.write(JSON.stringify(this.data));
        this.file.close();
        
        settings.LAST_SAVE=timestamp;
    };
    
    /* data initialization (likely happens only once) */
    this.load = function() { 
		this.file.open("r");
		this.data=JSON.parse(this.file.readAll(settings.FILE_BUFFER).join('\n'));
		this.file.close();     
    };
	
	/* create a copy of data object keys and give them 
	locking properties */
	this.init=function() {
        this.shadow=composite_sketch(this.data);
        /* initialize autosave timer */
        settings.LAST_SAVE = Date.now();
	}
    
    /* main "loop" called by server */
    this.cycle=function(timestamp) {

		if(!timestamp) 
			timestamp = Date.now();
	
		/* if we are due for a data update, save everything to file */
        if(timestamp - settings.LAST_SAVE >= settings.AUTO_SAVE) 
            this.save(timestamp);
		
		/* process request queue, removing successful operations */
		for(var r=0;r<this.queue.length;r++) {
			var request=this.queue[r];
			var result=false;
			
			/* locate the requested record within the database */
			var record=identify_remains.call(this,request.client,request.parent_name);
			
			switch(request.operation.toUpperCase()) {
			case "READ":
				result=this.read(request.client,record,request.child_name);
				break;
			case "WRITE":
				result=this.write(request.client,record,request.child_name,request.data);
				break;
			case "DELETE":
				result=this.delete(request.client,record,request.child_name);
				break;
			case "CREATE":
				result=this.create(request.client,record,request.child_name,request.data);
				break;
			case "SUBSCRIBE":
				result=this.subscribe(request.client,record,request.child_name);
				break;
			case "UNSUBSCRIBE":
				result=this.unsubscribe(request.client,record,request.child_name);
				break;
			case "LOCK":
				result=this.lock(request.client,record,request.child_name,request.data);
				break;
			}
			if(result == true) {
				log(LOG_DEBUG,
					"done: " + 
					request.operation + " " + 
					request.parent_name + "." + 
					request.child_name
				);
				this.queue.splice(r--,1);
			}
			else {
				log(LOG_DEBUG,
					"fail: " + 
					request.operation + " " + 
					request.parent_name + "." + 
					request.child_name
				);
			}
		}
    };

	/*************************** repository functions ****************************/
	/*  traverse object and create a shadow copy of the object structure
	for record locking and subscribers, and create hash names for database objects */
	function composite_sketch(obj,name,shadow,location)  {

		/* generate serialized location (maybe this can be removed )*/
		if(!location) 
			location=name;
		else
			location+="."+name;
			
		/* create shadow object */
		shadow=new Shadow();
		   
		/* iterate object members */
		for(var p in obj) {
			shadow[p]=composite_sketch(obj[p],p,shadow[p],location);
		}
		
		/* assign generated location id to this object */
		obj._location=location;
		
		/*  returns an object containing the passed objects property keys
		with their own lock, subscribers, and name properties
		also adds a location property to keys of original object */
		return shadow;
	}

	/* traverse object and remove location (hash name) tags  */
	function dismember(obj) { 
		delete obj._location;
		for(var p in obj) {
		   dismember(obj[p]);
		}
	}

	/* parse an object hash name and return the object (ex: dicewarz2.games.1.players.1.tiles.0)
	an object containing the corresponding data and its shadow object */
	function identify_remains(client,object_name) {

		var p=object_name.split(/\./);
		/* if the data request is invalid or empty, return an empty object */
		if(!p) {
			// Error!
			client.send(new Error(settings.ERROR_INVALID_REQUEST));
			return false;
		}

		var data=this.data;
		var shadow=this.shadow;
		var info={
			lock_type:settings.LOCK_NONE,
			lock_pending:false
		}

		/* iterate through split object name checking the keys against the database and 
		checking the lock statuses against the shadow copy */
		for each(var c in p) {
			
			data=data[c];
			shadow=shadow[c];
			
			/* if this key doesnt exist in the database, return error */
			if(!data || !shadow) {
				client.send(new Error(settings.ERROR_OBJECT_NOT_FOUND));
				return false;
			}

			/* check the current object's lock and subscriber status along the way */
			info = investigate(shadow,info);
		}
		
		/* continue on through the selected shadow object's children to check for locked children */
		info = search_party(data,shadow,info);
		
		/* return selected database object, shadow object, and overall lock status of the chosen tree */
		return new Record(data,shadow,info);
	}

	/* return the prevailing lock type and pending lock status for an object */
	function investigate(shadow, info) {
		/* if we havent found a write locked record yet, keep searching */
		if(info.lock_type == undefined) {
			for(var l in shadow._lock) {
				info.lock_type = shadow._lock[l].type;
				break;
			}
		}
		for(var s in shadow._subscribers) {
			info.subscribers[s]=shadow._subscribers[s];
		}
		info.lock_pending=shadow._lock_pending;
		return info;
	}

	/* recursively search object for any existing locked children, 
	return highest lock level (LOCK_WRITE > LOCK_READ > LOCK_NONE)  */
	function search_party(data,shadow,info) {
		if(!shadow)
			return info;
			
		info = investigate(shadow,info);
		for(var i in data) {
			info = search_party(data[i],shadow[i],info);
		}
		return info;
	}

	/* send updates of this object to all subscribers */
	function send_updates(record) {
		for each(var c in record.info.subscribers) {
			c.send(JSON.stringify(record.data)+"\r\n");
		}
	}

	/* constructor */
	this.load();
	this.init();
})();

}



